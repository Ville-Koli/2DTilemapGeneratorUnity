using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Tilemaps;

public class CAMapGen : MonoBehaviour
{
    public InitializeTilemap initTilemap;
    public GenSettings settings;
    public PhysicsBasedGen gc;
    public int celluralAutomataGen = 10;
    public bool gen = false;
    private int[] surroundNodes = new int[]{
        1, 0,
        -1, 0, 
        0, 1, 
        0, -1, 
        1, 1, 
       -1, 1, 
       1, -1, 
       -1, -1
       };
    private int width;
    private int height;
    /**
    <summary> Function, which counts the neighbours of the tile in the index i in the tilemap map </summary>
    <param name="height"> height of the map </param>
    <param name="i"> location of the tile in map </param>
    <param name="map"> tilemap in array form </param>
    <param name="width"> width of the map </param>
    <returns> how many neighbours the tile i has that are value of 0 and neighbours that are out of bounds are also considered as 0 </returns>
    **/
    int CountNeighbours(int[] map, int i, int width, int height){
        int x = i % width + settings.bounds.x;
        int y = i / height + settings.bounds.y;
        int neighbours = 0;
        for(int j = 1; j < surroundNodes.Length; j += 2){
            int loc = (y + surroundNodes[j - 1])*height + x + surroundNodes[j];
            if(0 <= loc && loc < map.Length){
                if(map[loc] == 0){
                    neighbours += 1;
                }
            }else{
                neighbours += 1;
            }
                
        }
        return neighbours;
    }

    /**
    <summary> Function, which generates a heightmap </summary>
    <param name="generations"> how many times cellural automata is run </param>
    <returns> returns the height map generated by cellural automata </returns>
    **/
    int[] GenerateAHeightMap(int generations){
        int[] heightMap = new int[width*height];
        float density = 60;
        for(int i = 0; i < heightMap.Length; ++i){
            if(UnityEngine.Random.Range(1, 101) > density){
                heightMap[i] = 1;
            }else{
                heightMap[i] = 0;
            }
                
        }
        // apply cellural automata
        for(int generation = 0; generation < generations; ++generation){
            int[] tempMap = new int[width*height];
            for(int i = 0; i < heightMap.Length; ++i){
                tempMap[i] = heightMap[i];
            }
            for(int i = 0; i < heightMap.Length; ++i){
                int info = CountNeighbours(tempMap, i, width, height);
                if(info > 4){
                    heightMap[i] = 0;
                }else{
                    heightMap[i] = 1;
                }
            }
        }
        return heightMap;
    }
    /**
    <summary> Function, which generates a heightmap with cellural automata and applies mountains, forests and shading to the map </summary>
    <returns> returns generated and enhanced map </returns>
    **/
    void GenerateMapBasedOnRandomHeightMap(){
        int[] map = GenerateAHeightMap(celluralAutomataGen);
        initTilemap.Start();
        Tilemap tilemap = initTilemap.GetTilemap();
        // turn tiles into darker versions
        for(int i = 0; i < map.Length; ++i){
            int x = i % width + settings.bounds.x;
            int y = i / height + settings.bounds.y;
            if(map[i] == 0){
                tilemap.SetTile(new Vector3Int(x, y), initTilemap.tiles["water_0"]);
            }else if(map[i] == 1){
                tilemap.SetTile(new Vector3Int(x, y), initTilemap.tiles["grass_0"]);
            }
        }
        // generate dark grass areas
        gc.DetailTheMap(false);
        // add mountains
        AddLayerOnTile(map, width, height, "mountain_0", settings.mountain_iterations, settings.mountain_probability, "dark_grass_0");
        AddLayerOnTile(map, width, height, "forest_tile_0", settings.forest_iterations, settings.forest_probability, "dark_grass_0");
        AddLayerOnTile(map, width, height, "grass_0", settings.grass_first_layer_iterations, settings.grass_first_layer_probability, "dark_grass_0");
        // generate dark mountains
        gc.DetailTheMap(false);
        // add snow layers to mountains
        gc.DetailTheMap(false);
        gc.DetailTheMap(true);
        // add brighter grass areas
        AddLayerOnTile(map, width, height, "grass_0", settings.grass_second_layer_iterations, settings.grass_second_layer_probability, "dark_grass_0");
    }
    /**
    <summary> Function, which applies tile to any tile given tile with a chance and expands the given tile to a surrounding tile with iterations </summary>
    <param name="height"> height of the map </param>
    <param name="percenage"> the chance for any tile in applyOnTiles to swap to tileName </param>
    <param name="map"> tilemap in array form </param>
    <param name="width"> width of the map </param>
    <param name="iterations"> how many times tileName type tiles are expanded </param>
    <param name="applyOnTiles"> tiles which have a chance of being swapped in the beginning of layering </param>
    **/
    void AddLayerOnTile(int[] map, int width, int height, string tileName, int iterations, float percentage, params string[] applyOnTiles){
        Tilemap tilemap = initTilemap.GetTilemap();
        for(int i = 0; i < map.Length; ++i){
            int x = i % width + settings.bounds.x;
            int y = i / height + settings.bounds.y;
            Vector3Int loc = new Vector3Int(x, y);
            TileBase tile = tilemap.GetTile(loc);
            foreach(var applyTile in applyOnTiles){
                if(tile != null && tile.name == applyTile && UnityEngine.Random.Range(0f, 1f) <= percentage){
                    tilemap.SetTile(loc, initTilemap.tiles[tileName]);
                }
            }
        }
        for(int j = 0; j < iterations; ++j){
            for(int i = 0; i < map.Length; ++i){
                int x, y;
                Vector3Int loc;
                x = i % width + settings.bounds.x;
                y = i / height + settings.bounds.y;
                loc = new Vector3Int(x, y);
                TileBase tile = tilemap.GetTile(loc);
                if(tile != null && tile.name == tileName){
                    Vector3Int newLoc = loc + new Vector3Int(UnityEngine.Random.Range(-1, 2), UnityEngine.Random.Range(-1, 2));
                    TileBase secondTile = tilemap.GetTile(newLoc);
                    foreach(var applyTile in applyOnTiles){
                        if(secondTile != null && (secondTile.name == applyTile)){
                            tilemap.SetTile(newLoc, initTilemap.tiles[tileName]);
                        }
                    }
                }
            }
            }
    }
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        width = Math.Abs(settings.bounds.xMax - settings.bounds.x);
        height = Math.Abs(settings.bounds.yMax - settings.bounds.y);        
    }

    // Update is called once per frame
    void Update()
    {
        if(gen){
            GenerateMapBasedOnRandomHeightMap();
            gen = false;
        }
    }
}
